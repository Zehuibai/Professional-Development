<!DOCTYPE html> <html lang=en style class=single-file-cut-mode><!--
 Page saved with SingleFile 
 url: https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/IBM-DA0151EN-SkillsNetwork/CheatSheet/Week2_CheatSheet_Data_Wrangling_with_Tidy.md.html?origin=www.coursera.org 
 saved date: Sat Aug 13 2022 10:22:11 GMT+0200 (Central European Summer Time)
--><meta charset=utf-8>
<meta name=viewport content="width=device-width, initial-scale=1">
<style>/*!
 * Bootstrap v4.3.1 (https://getbootstrap.com/)
 * Copyright 2011-2019 The Bootstrap Authors
 * Copyright 2011-2019 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 */:root{--blue:#007bff;--indigo:#6610f2;--purple:#6f42c1;--pink:#e83e8c;--red:#dc3545;--orange:#fd7e14;--yellow:#ffc107;--green:#28a745;--teal:#20c997;--cyan:#17a2b8;--white:#fff;--gray:#6c757d;--gray-dark:#343a40;--primary:#007bff;--secondary:#6c757d;--success:#28a745;--info:#17a2b8;--warning:#ffc107;--danger:#dc3545;--light:#f8f9fa;--dark:#343a40;--breakpoint-xs:0;--breakpoint-sm:576px;--breakpoint-md:768px;--breakpoint-lg:992px;--breakpoint-xl:1200px;--font-family-sans-serif:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";--font-family-monospace:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}*,::after,::before{box-sizing:border-box}html{font-family:sans-serif;line-height:1.15;-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:transparent}body{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";font-size:1rem;font-weight:400;line-height:1.5;color:#212529;text-align:left;background-color:#fff}[tabindex="-1"]:focus{outline:0!important}h2{margin-top:0}p{margin-top:0;margin-bottom:1rem}a{color:#007bff;text-decoration:none;background-color:transparent}a:hover{color:#0056b3;text-decoration:underline}a:not([href]):not([tabindex]){color:inherit;text-decoration:none}a:not([href]):not([tabindex]):focus,a:not([href]):not([tabindex]):hover{color:inherit;text-decoration:none}a:not([href]):not([tabindex]):focus{outline:0}code{font-family:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}img{vertical-align:middle;border-style:none}table{border-collapse:collapse}th{text-align:inherit}::-webkit-file-upload-button{font:inherit;-webkit-appearance:button}template{display:none}h2{margin-bottom:.5rem;line-height:1.2}h2{font-size:2rem}code{font-size:87.5%;color:#e83e8c;word-break:break-word}@-webkit-keyframes progress-bar-stripes{from{background-position:1rem 0}to{background-position:0 0}}@keyframes progress-bar-stripes{from{background-position:1rem 0}to{background-position:0 0}}@-webkit-keyframes spinner-border{to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes spinner-border{to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@-webkit-keyframes spinner-grow{0%{-webkit-transform:scale(0);transform:scale(0)}50%{opacity:1}}@keyframes spinner-grow{0%{-webkit-transform:scale(0);transform:scale(0)}50%{opacity:1}}@supports ((position:-webkit-sticky) or (position:sticky)){.sticky-top{position:-webkit-sticky;position:sticky;top:0;z-index:1020}}img{max-width:100%;height:auto}body{padding:10px;margin:10px}table td,table th{padding:0.75rem;vertical-align:top;border-top:1px solid #dee2e6}h2{font-weight:500;padding-top:20px}@keyframes caretBlink{from{opacity:1.0}to{opacity:0.0}}@keyframes rotateSpinner{from{transform:rotate(0deg)}to{transform:rotate(360deg)}}.sf-hidden{display:none!important}</style><link rel=canonical href="https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/IBM-DA0151EN-SkillsNetwork/CheatSheet/Week2_CheatSheet_Data_Wrangling_with_Tidy.md.html?origin=www.coursera.org"><meta http-equiv=content-security-policy content="default-src 'none'; font-src 'self' data:; img-src 'self' data:; style-src 'unsafe-inline'; media-src 'self' data:; script-src 'unsafe-inline' data:;"><style>img[src="data:,"],source[src="data:,"]{display:none!important}</style></head>
 <body data-new-gr-c-s-check-loaded=14.1073.0 data-gr-ext-installed class>
 <h2 class>CheatSheet - Data Wrangling with Tidyverse</h2>
 
 <p></p>
 <table class>
 <tbody>
 <tr>
 <th style=width:10% class>Commands</th>
 <th style=width:30% class>Syntax</th>
 <th style=width:30%>Description</th>
 <th style=width:30%>Example</th>
 </tr>
 <tr>
 <td style=width:10% class>install package</td>
 <td style=width:30% class><code>install.packages("packagename")</code></td>
 <td style=width:30%><code>install.packages</code> is used to install the packages from the R library.</td>
 <td style=width:30%><code>install.packages("tidyverse")</code></td>
 </tr>
 <tr>
 <td style=width:10%>load package</td>
 <td style=width:30% class><code>library(packagename)</code></td>
 <td style=width:30%><code>library()</code> Load the package from R library.</td>
 <td style=width:30%><code>library(tidyverse)</code></td>
 </tr>
 <tr>
 <td style=width:10%>download.file</td>
 <td style=width:30% class><code class>download.file(url, destfile, method, quiet = FALSE, mode = "w",cacheOK = TRUE,headers = NULL, ‚Ä¶)</code></td>
 <td style=width:30%><code>download.file() to download the file locally using the download.file() function.<p>url naming the URL of a resource to be downloaded.<p>destfile a character string with the name where the downloaded file is saved.</p></code></td>
 <td style=width:30%><code>download.file(url, destfile = "lax_to_jfk.tar.gz")</code></td>
 </tr>
 <tr>
 <td style=width:10%>untar</td>
 <td style=width:30% class><code>untar()</code></td>
 <td style=width:30%><code>untar()</code> is used to extract files from a tar archive is done with untar function from the utils package.</td>
 <td style=width:30%><code>untar("lax_to_jfk.tar.gz")</code></td>
 </tr>
 <tr>
 <td style=width:10%>read_csv</td>
 <td style=width:30%><code class>read_csv(file)</code></td>
 <td style=width:30%><code>read_csv()</code> reads the csv file using readr package.</td>
 <td style=width:30%><code>read_csv("lax_to_jfk/lax_to_jfk.csv")</code></td>
 </tr>
 <tr>
 <th style=width:20%>Missing Values and Formatting</th>
 </tr>
 <tr>
 <td style=width:10%>is.na</td>
 <td style=width:30%><code>is.na(x)</code></td>
 <td style=width:30%><code>is.na(x)</code> returns a vector of TRUE or FALSE depending if the according element in x is NA or not.</td>
 <td style=width:30%><code>is.na(c(1, na))</code> # FALSE TRUE</td>
 </tr>
 <tr>
 <td style=width:10%>anyNA</td>
 <td style=width:30%><code class>anyNA(x, recursive = FALSE)</code></td>
 <td style=width:30%><code>anyNA()</code> returns TRUE if x contains any NAs and FALSE otherwise.</td>
 <td style=width:30%><code>anyNA(c(1, na))</code> # TRUE</td>
 </tr>
 <tr>
 <td style=width:10%>sum</td>
 <td style=width:30%><code>sum(object)</code></td>
 <td style=width:30%><code>sum()</code> is used to calculate sum.</td>
 <td style=width:30%><code>sum(is.na(carrierdelay))</code></td>
 </tr>
 <tr>
 <td style=width:10%>summarize</td>
 <td style=width:30% class><code class>summarize(X, by, FUN, ‚Ä¶,stat.name=deparse(substitute(X)),type=c('variables','matrix'), subset=TRUE,keepcolnames=FALSE)</code></td>
 <td style=width:30%><code>summarize()</code> function reduces a data frame to a summary of just one vector or value.
 <p>X a vector or matrix capable of being operated on by the function specified as the FUN argument</p>
 <p>by one or more stratification variables. If a single variable, by may be a vector, otherwise it should be a list.</p>
 <p>FUN a function of a single vector argument, used to create the statistical summaries for summarize. FUN may compute any number of statistics.</p>
 </td>
 <td style=width:30%><code>summarize(count = sum(is.na(carrierdelay)))</code></td>
 </tr>
 <tr>
 <td style=width:10%>map</td>
 <td style=width:30%><code class>map(.x, .f, ...)</code></td>
 <td style=width:30%><code>map()</code> functions transform their input by applying a function to each element and returning a vector the same length as the input.</td>
 <td style=width:30%><code>map(sub_airline, ~sum(is.na(.)))</code></td>
 </tr>
 <tr>
 <td style=width:10%>dim</td>
 <td style=width:30%><code>dim(object)</code></td>
 <td style=width:30%><code>dim</code> returns the dimension of the matrix, array, or data frame.</td>
 <td style=width:30%><code>dim(sub_airline)</code></td>
 </tr>
 <tr>
 <td style=width:10%>drop_na</td>
 <td style=width:30%><code>drop_na(object)</code></td>
 <td style=width:30%><code>drop_na()</code> drop rows containing missing values.</td>
 <td style=width:30%><code>drop_na(carrierdelay)</code></td>
 </tr>
 <tr>
 <td style=width:10%>replace_na</td>
 <td style=width:30%><code>replace_na(data, replace, ...)</code></td>
 <td style=width:30%><code>replace_na</code> replace missing values.
 <p>data A data frame or vector.</p>
 <p>replace If data is a data frame, a named list giving the value to replace NA with for each column. If data is a vector, a single value used for replacement.</p>
 </td>
 <td style=width:30%><code>replace_na(list(carrierdelay = 0,
weatherdelay = 0,
nasdelay = 0,
securitydelay = 0,
lateaircraftdelay = 0))</code></td>
 </tr>
 <tr>
 <td style=width:10%>mean</td>
 <td style=width:30%><code>mean(x, na.rm)</code></td>
 <td style=width:30%><code>mean()</code> calculate the arithmetic mean of the elements of the numeric vector passed to it as argument.</td>
 <td style=width:30%><code>mean(drop_na_rows$carrierdelay)</code></td>
 </tr>
 <tr>
 <td style=width:10%>mutate,<br>mutate_all,<br>mutate_if</td>
 <td style=width:30%><code>mutate(data, ...)</code></td>
 <td style=width:30%><code>mutate</code> function in R (mutate, mutate_all and mutate_at) is used to create new variable or column to the dataframe in R.</td>
 <td style=width:30%><code>date_airline %&gt;%
select(year, month, day) %&gt;%
mutate_all(type.convert) %&gt;%
mutate_if(is.character, as.numeric)</code></td>
 </tr>
 <tr>
 <th style=width:20%>Data Normalization</th>
 </tr>
 <tr>
 <td style=width:10%>Simple scaling</td>
 <td style=width:30%><code>xnew=xold/xmax</code></td>
 <td style=width:30%>Simple scaling divides each value by the maximum value in a feature. The new range is between 0 and 1.</td>
 <td style=width:30%><code>sub_airline$arrdelay / max(sub_airline$arrdelay)</code></td>
 </tr>
 <tr>
 <td style=width:10%>Min-max</td>
 <td style=width:30%><code>xnew= (xold-xmax) / (xmax-xmin)</code></td>
 <td style=width:30%>Min-max subtracts the minimum value from the original and divides by the maximum minus the minimum. The minimum becomes 0 and the maximum becomes 1.</td>
 <td style=width:30%><code>(sub_airline$arrdelay - min(sub_airline$arrdelay)) /(max(sub_airline$arrdelay) - min(sub_airline$arrdelay))</code></td>
 </tr>
 <tr>
 <td style=width:10%>Z-score</td>
 <td style=width:30%><code>xnew= (xold - ùúá) / ùúé</code></td>
 <td style=width:30%>Standardization (Z-score) subtracts the mean ( ùúá ) of the feature and divides by the standard deviation ( ùúé ).</td>
 <td style=width:30%><code>(sub_airline$arrdelay - mean(sub_airline$arrdelay)) / sd(sub_airline$arrdelay)</code></td>
 </tr>
 <tr>
 <th style=width:20%>Binning Data</th>
 </tr>
 <tr>
 <td style=width:10%>ggplot</td>
 <td style=width:30%><code>ggplot(df, aes(x, y, other aesthetics))</code></td>
 <td style=width:30%><code>ggplot</code> is a plotting package that makes it simple to create complex plots from data in a data frame.</td>
 <td style=width:30%><code>ggplot(data = sub_airline, mapping = aes(x = arrdelay)) +
geom_histogram(bins = 100, color = "white", fill = "red")</code></td>
 </tr>
 <tr>
 <td style=width:10%>ntile</td>
 <td style=width:30%><code>ntile(data)</code></td>
 <td style=width:30%><code>ntile()</code> function is used to divide the data into N bins there by providing ntile rank.</td>
 <td style=width:30%><code>sub_airline %&gt;%
mutate(quantile_rank = ntile(sub_airline$arrdelay,4))</code></td>
 </tr>
 <tr>
 <td style=width:10%>geom_histogram</td>
 <td style=width:30%><code>geom_histogram(*arguments)</code></td>
 <td style=width:30%><code>geom_histogram()</code> function display the counts with bars.</td>
 <td style=width:30%><code>geom_histogram(bins = 4, color = "white", fill = "red")</code></td>
 </tr>
 <tr>
 <th style=width:20%>Indicator variable</th>
 </tr>
 <tr>
 <td style=width:10%>spread</td>
 <td style=width:30% class><code class>spread(data, key, value)</code></td>
 <td style=width:30%><code>spread</code> a key-value pair across multiple columns<br>* data is your dataframe of interest.<br>* key is the column whose values will become variable names.<br>* value is the column where values will fill in under the new variables created from key.</td>
 <td style=width:30%><code>sub_airline %&gt;%
spread(reporting_airline, arrdelay)</code></td>
 </tr>
 <tr>
 <td style=width:10% class>slice</td>
 <td style=width:30% class><code>slice(num1 : num5 )</code></td>
 <td style=width:30%><code>slice()</code>looks at the specified rows.</td>
 <td style=width:30%><code>slice(1:5)</code></td>
 </tr>
 <tr>
 <td style=width:10% class>factor</td>
 <td style=width:30% class><code>factor(x)</code></td>
 <td style=width:30%><code>factor() </code>function is used to encode a vector as a factor, If argument ordered is TRUE, the factor levels are assumed to be ordered.</td>
 <td style=width:30%><code>sub_airline %&gt;%
mutate(reporting_airline = factor(reporting_airline,labels = c("aa", "as", "dl", "ua", "b6", "pa (1)", "hp", "tw", "vx")))</code></td>
 </tr>
 </tbody>
 </table>
 
 <p class></p>
 
 
 
 
 
 
 
<div id=CodeBadgeTemplate style=display:none>
 
</div><grammarly-desktop-integration data-grammarly-shadow-root=true><template shadowroot=open><style class="sf-hidden">div.grammarly-desktop-integration{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}div.grammarly-desktop-integration:before{content:attr(data-content)}</style><div aria-label="grammarly-integration" role="group" tabindex="-1" class="grammarly-desktop-integration" data-content="{&quot;mode&quot;:&quot;full&quot;,&quot;isActive&quot;:true,&quot;isUserDisabled&quot;:false}"></div></template></grammarly-desktop-integration><script data-template-shadow-root>(()=>{document.currentScript.remove();processNode(document);function processNode(node){node.querySelectorAll("template[shadowroot]").forEach(element=>{let shadowRoot = element.parentElement.shadowRoot;if (!shadowRoot) {try {shadowRoot=element.parentElement.attachShadow({mode:element.getAttribute("shadowroot")});shadowRoot.innerHTML=element.innerHTML;element.remove()} catch (error) {} if (shadowRoot) {processNode(shadowRoot)}}})}})()</script><script data-template-shadow-root>(() => { document.currentScript.remove(); const processNode = node => { node.querySelectorAll("template[shadowroot]").forEach(element=>{ let shadowRoot = getShadowRoot(element.parentElement); if (!shadowRoot) { try { shadowRoot = element.parentElement.attachShadow({mode:element.getAttribute("shadowroot")}); shadowRoot.innerHTML = element.innerHTML; element.remove(); } catch (error) {} if (shadowRoot) { processNode(shadowRoot); } } }) }; const FORBIDDEN_TAG_NAMES = ["a","area","audio","base","br","col","command","embed","hr","img","iframe","input","keygen","link","meta","param","source","track","video","wbr"]; const NOTE_TAGNAME = "single-file-note"; const NOTE_CLASS = "note"; const NOTE_ANCHORED_CLASS = "note-anchored"; const NOTE_SELECTED_CLASS = "note-selected"; const NOTE_MOVING_CLASS = "note-moving"; const NOTE_MASK_MOVING_CLASS = "note-mask-moving"; const MASK_CLASS = "single-file-mask"; const HIGHLIGHT_CLASS = "single-file-highlight"; const NOTES_WEB_STYLESHEET = ".note { all: initial; display: flex; flex-direction: column; height: 150px; width: 150px; position: absolute; top: 10px; left: 10px; border: 1px solid rgb(191, 191, 191); z-index: 2147483646; box-shadow: 3px 3px 3px rgba(33, 33, 33, .7); min-height: 100px; min-width: 100px; } .note-selected { z-index: 2147483647; } .note-hidden { display: none; } .note-collapsed { min-height: 30px; max-height: 30px; overflow: hidden; } .note textarea { all: initial; white-space: break-spaces; font-family: Arial, Helvetica, sans-serif; font-size: 14px; padding: 3px; height: 100%; border: 1px solid transparent; resize: none; color: black; } .note textarea:focus { border: 1px dotted rgb(160, 160, 160); } .note header { all: initial; min-height: 30px; cursor: grab; user-select: none; } .note .note-remove { all: initial; position: absolute; right: 0px; top: 2px; padding: 5px; opacity: .5; cursor: pointer; user-select: none; width: 16px; height: 16px; } .note .note-anchor { all: initial; position: absolute; left: 0px; top: 2px; padding: 5px; opacity: .25; cursor: pointer; width: 16px; height: 16px; } .note .note-resize { all: initial; position: absolute; bottom: -5px; right: -5px; height: 15px; width: 15px; cursor: nwse-resize; user-select: none; } .note .note-remove:hover { opacity: 1; } .note .note-anchor:hover { opacity: .5; } .note-anchored .note-anchor { opacity: .5; } .note-anchored .note-anchor:hover { opacity: 1; } .note-moving { opacity: .75; box-shadow: 6px 6px 3px rgba(33, 33, 33, .7); } .note-moving * { cursor: grabbing; } .note-yellow header { background-color: #f5f545; } .note-yellow textarea { background-color: #ffff7c; } .note-pink header { background-color: #ffa59f; } .note-pink textarea { background-color: #ffbbb6; } .note-blue header { background-color: #84c8ff; } .note-blue textarea { background-color: #95d0ff; } .note-green header { background-color: #93ef8d; } .note-green textarea { background-color: #9cff95; }"; const MASK_WEB_STYLESHEET = ".note-mask { all: initial; position: fixed; z-index: 2147483645; pointer-events: none; background-color: transparent; transition: background-color 125ms; } .note-mask-moving.note-yellow { background-color: rgba(255, 255, 124, .3); } .note-mask-moving.note-pink { background-color: rgba(255, 187, 182, .3); } .note-mask-moving.note-blue { background-color: rgba(149, 208, 255, .3); } .note-mask-moving.note-green { background-color: rgba(156, 255, 149, .3); } .page-mask { all: initial; position: fixed; top: 0; left: 0; width: 0; height: 0; z-index: 2147483646; } .page-mask-active { width: 100vw; height: 100vh; }"; const NOTE_HEADER_HEIGHT = 25; const PAGE_MASK_ACTIVE_CLASS = "page-mask-active"; const REMOVED_CONTENT_CLASS = "single-file-removed"; const reflowNotes = function reflowNotes() { document.querySelectorAll(NOTE_TAGNAME).forEach(containerElement => { const noteElement = containerElement.shadowRoot.querySelector("." + NOTE_CLASS); const noteBoundingRect = noteElement.getBoundingClientRect(); const anchorElement = getAnchorElement(containerElement); const anchorBoundingRect = anchorElement.getBoundingClientRect(); const maxX = anchorBoundingRect.x + Math.max(0, anchorBoundingRect.width - noteBoundingRect.width); const minX = anchorBoundingRect.x; const maxY = anchorBoundingRect.y + Math.max(0, anchorBoundingRect.height - NOTE_HEADER_HEIGHT); const minY = anchorBoundingRect.y; let left = parseInt(noteElement.style.getPropertyValue("left")); let top = parseInt(noteElement.style.getPropertyValue("top")); if (noteBoundingRect.x > maxX) { left -= noteBoundingRect.x - maxX; } if (noteBoundingRect.x < minX) { left += minX - noteBoundingRect.x; } if (noteBoundingRect.y > maxY) { top -= noteBoundingRect.y - maxY; } if (noteBoundingRect.y < minY) { top += minY - noteBoundingRect.y; } noteElement.style.setProperty("position", "absolute"); noteElement.style.setProperty("left", left + "px"); noteElement.style.setProperty("top", top + "px"); }); }; const addNoteRef = function addNoteRef(anchorElement, noteId) { const noteRefs = getNoteRefs(anchorElement); noteRefs.push(noteId); setNoteRefs(anchorElement, noteRefs); }; const deleteNoteRef = function deleteNoteRef(containerElement, noteId) { const anchorElement = getAnchorElement(containerElement); const noteRefs = getNoteRefs(anchorElement).filter(noteRefs => noteRefs != noteId); if (noteRefs.length) { setNoteRefs(anchorElement, noteRefs); } else { delete anchorElement.dataset.singleFileNoteRefs; } }; const getNoteRefs = function getNoteRefs(anchorElement) { return JSON.parse("[" + (anchorElement.dataset.singleFileNoteRefs || "") + "]"); }; const setNoteRefs = function setNoteRefs(anchorElement, noteRefs) { anchorElement.dataset.singleFileNoteRefs = noteRefs.toString(); }; const getAnchorElement = function getAnchorElement(containerElement) { return document.querySelector("[data-single-file-note-refs^=" + JSON.stringify(containerElement.dataset.noteId) + "], [data-single-file-note-refs$=" + JSON.stringify(containerElement.dataset.noteId) + "], [data-single-file-note-refs*=" + JSON.stringify("," + containerElement.dataset.noteId + ",") + "]") || document.documentElement; }; const getMaskElement = function getMaskElement(className, containerClassName) { let maskElement = document.documentElement.querySelector("." + className); if (!maskElement) { maskElement = document.createElement("div"); const maskContainerElement = document.createElement("div"); if (containerClassName) { maskContainerElement.classList.add(containerClassName); } maskContainerElement.classList.add(MASK_CLASS); const firstNote = document.querySelector(NOTE_TAGNAME); if (firstNote && firstNote.parentElement == document.documentElement) { document.documentElement.insertBefore(maskContainerElement, firstNote); } else { document.documentElement.appendChild(maskContainerElement); } maskElement.classList.add(className); const maskShadow = maskContainerElement.attachShadow({ mode: "open" }); maskShadow.appendChild(getStyleElement(MASK_WEB_STYLESHEET)); maskShadow.appendChild(maskElement); return maskElement; } }; const getStyleElement = function getStyleElement(stylesheet) { const linkElement = document.createElement("style"); linkElement.textContent = stylesheet; return linkElement; }; const attachNoteListeners = function attachNoteListeners(containerElement, editable = false) { const SELECT_PX_THRESHOLD = 4; const COLLAPSING_NOTE_DELAY = 750; const noteShadow = containerElement.shadowRoot; const noteElement = noteShadow.childNodes[1]; const headerElement = noteShadow.querySelector("header"); const mainElement = noteShadow.querySelector("textarea"); const noteId = containerElement.dataset.noteId; const resizeElement = noteShadow.querySelector(".note-resize"); const anchorIconElement = noteShadow.querySelector(".note-anchor"); const removeNoteElement = noteShadow.querySelector(".note-remove"); mainElement.readOnly = !editable; if (!editable) { anchorIconElement.style.setProperty("display", "none", "important"); } else { anchorIconElement.style.removeProperty("display"); } headerElement.ontouchstart = headerElement.onmousedown = event => { if (event.target == headerElement) { collapseNoteTimeout = setTimeout(() => { noteElement.classList.toggle("note-collapsed"); hideMaskNote(); }, COLLAPSING_NOTE_DELAY); event.preventDefault(); const position = getPosition(event); const clientX = position.clientX; const clientY = position.clientY; const boundingRect = noteElement.getBoundingClientRect(); const deltaX = clientX - boundingRect.left; const deltaY = clientY - boundingRect.top; maskPageElement.classList.add(PAGE_MASK_ACTIVE_CLASS); document.documentElement.style.setProperty("user-select", "none", "important"); anchorElement = getAnchorElement(containerElement); displayMaskNote(); selectNote(noteElement); moveNote(event, deltaX, deltaY); movingNoteMode = { event, deltaX, deltaY }; document.documentElement.ontouchmove = document.documentElement.onmousemove = event => { clearTimeout(collapseNoteTimeout); if (!movingNoteMode) { movingNoteMode = { deltaX, deltaY }; } movingNoteMode.event = event; moveNote(event, deltaX, deltaY); }; } }; resizeElement.ontouchstart = resizeElement.onmousedown = event => { event.preventDefault(); resizingNoteMode = true; selectNote(noteElement); maskPageElement.classList.add(PAGE_MASK_ACTIVE_CLASS); document.documentElement.style.setProperty("user-select", "none", "important"); document.documentElement.ontouchmove = document.documentElement.onmousemove = event => { event.preventDefault(); const { clientX, clientY } = getPosition(event); const boundingRectNote = noteElement.getBoundingClientRect(); noteElement.style.width = clientX - boundingRectNote.left + "px"; noteElement.style.height = clientY - boundingRectNote.top + "px"; }; }; anchorIconElement.ontouchend = anchorIconElement.onclick = event => { event.preventDefault(); noteElement.classList.toggle(NOTE_ANCHORED_CLASS); if (!noteElement.classList.contains(NOTE_ANCHORED_CLASS)) { deleteNoteRef(containerElement, noteId); addNoteRef(document.documentElement, noteId); } onUpdate(false); }; removeNoteElement.ontouchend = removeNoteElement.onclick = event => { event.preventDefault(); deleteNoteRef(containerElement, noteId); containerElement.remove(); }; noteElement.onmousedown = () => { selectNote(noteElement); }; function moveNote(event, deltaX, deltaY) { event.preventDefault(); const { clientX, clientY } = getPosition(event); noteElement.classList.add(NOTE_MOVING_CLASS); if (editable) { if (noteElement.classList.contains(NOTE_ANCHORED_CLASS)) { deleteNoteRef(containerElement, noteId); anchorElement = getTarget(clientX, clientY) || document.documentElement; addNoteRef(anchorElement, noteId); } else { anchorElement = document.documentElement; } } document.documentElement.insertBefore(containerElement, maskPageElement.getRootNode().host); noteElement.style.setProperty("left", (clientX - deltaX) + "px"); noteElement.style.setProperty("top", (clientY - deltaY) + "px"); noteElement.style.setProperty("position", "fixed"); displayMaskNote(); } function displayMaskNote() { if (anchorElement == document.documentElement || anchorElement == document.documentElement) { hideMaskNote(); } else { const boundingRectAnchor = anchorElement.getBoundingClientRect(); maskNoteElement.classList.add(NOTE_MASK_MOVING_CLASS); if (selectedNote) { maskNoteElement.classList.add(selectedNote.dataset.color); } maskNoteElement.style.setProperty("top", (boundingRectAnchor.y - 3) + "px"); maskNoteElement.style.setProperty("left", (boundingRectAnchor.x - 3) + "px"); maskNoteElement.style.setProperty("width", (boundingRectAnchor.width + 3) + "px"); maskNoteElement.style.setProperty("height", (boundingRectAnchor.height + 3) + "px"); } } function hideMaskNote() { maskNoteElement.classList.remove(NOTE_MASK_MOVING_CLASS); if (selectedNote) { maskNoteElement.classList.remove(selectedNote.dataset.color); } } function selectNote(noteElement) { if (selectedNote) { selectedNote.classList.remove(NOTE_SELECTED_CLASS); maskNoteElement.classList.remove(selectedNote.dataset.color); } noteElement.classList.add(NOTE_SELECTED_CLASS); noteElement.classList.add(noteElement.dataset.color); selectedNote = noteElement; } function getTarget(clientX, clientY) { const targets = Array.from(document.elementsFromPoint(clientX, clientY)).filter(element => element.matches("html *:not(" + NOTE_TAGNAME + "):not(." + MASK_CLASS + ")")); if (!targets.includes(document.documentElement)) { targets.push(document.documentElement); } let newTarget, target = targets[0], boundingRect = target.getBoundingClientRect(); newTarget = determineTargetElement("floor", target, clientX - boundingRect.left, getMatchedParents(target, "left")); if (newTarget == target) { newTarget = determineTargetElement("ceil", target, boundingRect.left + boundingRect.width - clientX, getMatchedParents(target, "right")); } if (newTarget == target) { newTarget = determineTargetElement("floor", target, clientY - boundingRect.top, getMatchedParents(target, "top")); } if (newTarget == target) { newTarget = determineTargetElement("ceil", target, boundingRect.top + boundingRect.height - clientY, getMatchedParents(target, "bottom")); } target = newTarget; while (boundingRect = target && target.getBoundingClientRect(), boundingRect && boundingRect.width <= SELECT_PX_THRESHOLD && boundingRect.height <= SELECT_PX_THRESHOLD) { target = target.parentElement; } return target; } function getMatchedParents(target, property) { let element = target, matchedParent, parents = []; do { const boundingRect = element.getBoundingClientRect(); if (element.parentElement && !element.parentElement.tagName.toLowerCase() != NOTE_TAGNAME && !element.classList.contains(MASK_CLASS)) { const parentBoundingRect = element.parentElement.getBoundingClientRect(); matchedParent = Math.abs(parentBoundingRect[property] - boundingRect[property]) <= SELECT_PX_THRESHOLD; if (matchedParent) { if (element.parentElement.clientWidth > SELECT_PX_THRESHOLD && element.parentElement.clientHeight > SELECT_PX_THRESHOLD && ((element.parentElement.clientWidth - element.clientWidth > SELECT_PX_THRESHOLD) || (element.parentElement.clientHeight - element.clientHeight > SELECT_PX_THRESHOLD))) { parents.push(element.parentElement); } element = element.parentElement; } } else { matchedParent = false; } } while (matchedParent && element); return parents; } function determineTargetElement(roundingMethod, target, widthDistance, parents) { if (Math[roundingMethod](widthDistance / SELECT_PX_THRESHOLD) <= parents.length) { target = parents[parents.length - Math[roundingMethod](widthDistance / SELECT_PX_THRESHOLD) - 1]; } return target; } }; const anchorNote = function anchorNote(event, noteElement, deltaX, deltaY) { event.preventDefault(); const { clientX, clientY } = getPosition(event); document.documentElement.style.removeProperty("user-select"); noteElement.classList.remove(NOTE_MOVING_CLASS); maskNoteElement.classList.remove(NOTE_MASK_MOVING_CLASS); maskPageElement.classList.remove(PAGE_MASK_ACTIVE_CLASS); maskNoteElement.classList.remove(noteElement.dataset.color); const headerElement = noteElement.querySelector("header"); headerElement.ontouchmove = document.documentElement.onmousemove = null; let currentElement = anchorElement; let positionedElement; while (currentElement.parentElement && !positionedElement) { if (!FORBIDDEN_TAG_NAMES.includes(currentElement.tagName.toLowerCase())) { const currentElementStyle = getComputedStyle(currentElement); if (currentElementStyle.position != "static") { positionedElement = currentElement; } } currentElement = currentElement.parentElement; } if (!positionedElement) { positionedElement = document.documentElement; } const containerElement = noteElement.getRootNode().host; if (positionedElement == document.documentElement) { const firstMaskElement = document.querySelector("." + MASK_CLASS); firstMaskElement.parentElement.insertBefore(containerElement, firstMaskElement); } else { positionedElement.appendChild(containerElement); } const boundingRectPositionedElement = positionedElement.getBoundingClientRect(); const stylePositionedElement = window.getComputedStyle(positionedElement); const borderX = parseInt(stylePositionedElement.getPropertyValue("border-left-width")); const borderY = parseInt(stylePositionedElement.getPropertyValue("border-top-width")); noteElement.style.setProperty("position", "absolute"); noteElement.style.setProperty("left", (clientX - boundingRectPositionedElement.x - deltaX - borderX) + "px"); noteElement.style.setProperty("top", (clientY - boundingRectPositionedElement.y - deltaY - borderY) + "px"); }; const getPosition = function getPosition(event) { if (event.touches && event.touches.length) { const touch = event.touches[0]; return touch; } else { return event; } }; const onMouseUp = function onMouseUp(event) { if (highlightSelectionMode) { highlightSelection(); onUpdate(false); } if (removeHighlightMode) { let element = event.target, done; while (element && !done) { if (element.classList.contains(HIGHLIGHT_CLASS)) { document.querySelectorAll("." + HIGHLIGHT_CLASS + "[data-singlefile-highlight-id=" + JSON.stringify(element.dataset.singlefileHighlightId) + "]").forEach(highlightedElement => { resetHighlightedElement(highlightedElement); onUpdate(false); }); done = true; } element = element.parentElement; } } if (resizingNoteMode) { resizingNoteMode = false; document.documentElement.style.removeProperty("user-select"); maskPageElement.classList.remove(PAGE_MASK_ACTIVE_CLASS); document.documentElement.ontouchmove = document.documentElement.onmousemove = null; onUpdate(false); } if (movingNoteMode) { anchorNote(movingNoteMode.event || event, selectedNote, movingNoteMode.deltaX, movingNoteMode.deltaY); movingNoteMode = null; document.documentElement.ontouchmove = document.documentElement.onmousemove = null; onUpdate(false); } if (collapseNoteTimeout) { clearTimeout(collapseNoteTimeout); collapseNoteTimeout = null; } if ((cuttingMode || cuttingOuterMode) && cuttingPath) { if (event.ctrlKey) { const element = cuttingPath[cuttingPathIndex]; element.classList.toggle(cuttingMode ? CUT_SELECTED_CLASS : CUT_OUTER_SELECTED_CLASS); } else { validateCutElement(event.shiftKey); } } }; const getShadowRoot = function getShadowRoot(element) { const chrome = window.chrome; if (element.openOrClosedShadowRoot) { return element.openOrClosedShadowRoot; } else if (chrome && chrome.dom && chrome.dom.openOrClosedShadowRoot) { try { return chrome.dom.openOrClosedShadowRoot(element); } catch (error) { return element.shadowRoot; } } else { return element.shadowRoot; } }; const maskNoteElement = getMaskElement("note-mask"); const maskPageElement = getMaskElement("page-mask", "single-file-page-mask"); let selectedNote, highlightSelectionMode, removeHighlightMode, resizingNoteMode, movingNoteMode, collapseNoteTimeout, cuttingMode, cuttingOuterMode; window.onresize = reflowNotes; window.onUpdate = () => {}; document.documentElement.onmouseup = document.documentElement.ontouchend = onMouseUp; window.addEventListener("DOMContentLoaded", () => { processNode(document); reflowNotes(); document.querySelectorAll("single-file-note").forEach(noteElement => attachNoteListeners(noteElement)); }); })()</script><style>.single-file-highlight-yellow, .single-file-highlight-yellow-mode ::selection { background-color: #ffff7c !important; color: black !important; } .single-file-highlight-pink, .single-file-highlight-pink-mode ::selection { background-color: #ffbbb6 !important; color: black !important; } .single-file-highlight-blue, .single-file-highlight-blue-mode ::selection { background-color: #95d0ff !important; color: black !important; } .single-file-highlight-green, .single-file-highlight-green-mode ::selection { background-color: #93ef8d !important; color: black !important; } span.single-file-highlight-yellow, span.single-file-highlight-pink, span.single-file-highlight-blue, span.single-file-highlight-green { display: inline !important; } .single-file-highlight-hidden { background-color: inherit !important; color: inherit !important; } .single-file-mask { all: initial; display: contents !important; } .single-file-mask.single-file-page-mask { opacity: .99 !important; } single-file-note { all: initial !important; display: contents !important; } .single-file-cut-hover, .single-file-cut-outer-hover, .single-file-cut-selected, .single-file-cut-outer-selected { transition: outline-width 125ms !important; outline-offset: -4px !important; outline-width: 4px !important; } .single-file-cut-hover, .single-file-cut-outer-hover { outline-style: dotted !important; } .single-file-cut-selected, .single-file-cut-outer-selected { outline-style: dashed !important; } .single-file-cut-hover, .single-file-cut-selected { outline-color: red !important; } .single-file-cut-outer-hover, .single-file-cut-outer-selected { outline-color: green !important; } .single-file-cut-mode, .single-file-cut-mode * { pointer-events: auto !important; } .single-file-cut-hover, .single-file-cut-outer-hover, .single-file-remove-highlights-mode .single-file-highlight:hover { cursor: crosshair !important; } .single-file-removed { display: none !important; float: none !important; position: static !important; visibility: collapse !important; }</style>